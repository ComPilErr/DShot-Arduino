#include "Arduino.h"
#include "DShot.h"

static uint16_t dShotPacket;

static inline void dShot300_0(){
  OUTPUT_HIGH;
  // wait about 1.25us
  NOP8;NOP4;NOP2;
  OUTPUT_LOW;
  // wait 3.33us-1.25us
  NOP16;NOP4;
}

static inline void dShot300_1(){
  OUTPUT_HIGH;
  // wait about 2.5us - 40 cycles
  NOP32;NOP2;
  OUTPUT_LOW;
  // wait 2 cycles for next bit
  NOP2;
}

/*
  Currently supports only one ESC, can expand in the future
*/
static inline void sendData(){
  noInterrupts();
  // MSB first
  uint16_t mask = 0x8000;
  while (mask!=0) {
    if (dShotPacket & mask)
      dShot300_1();
    else
      dShot300_0();
    mask >>= 1;
  }
  interrupts();
}


/*
  Generated by:
  http://www.8bit-era.cz/arduino-timer-interrupts-calculator.html
  1000 Hz Update rate
*/
static void initISR(){
  // TIMER 1 for interrupt frequency 1000 Hz:
  cli(); // stop interrupts
  TCCR1A = 0; // set entire TCCR1A register to 0
  TCCR1B = 0; // same for TCCR1B
  TCNT1  = 0; // initialize counter value to 0
  // set compare match register for 1000 Hz increments
  OCR1A = 15999; // = 16000000 / (1 * 1000) - 1 (must be <65536)
  // turn on CTC mode
  TCCR1B |= (1 << WGM12);
  // Set CS12, CS11 and CS10 bits for 1 prescaler
  TCCR1B |= (0 << CS12) | (0 << CS11) | (1 << CS10);
  // enable timer compare interrupt
  TIMSK1 |= (1 << OCIE1A);
  sei(); // allow interrupts
}

static boolean isTimerActive(){
  return true;
}

ISR(TIMER1_COMPA_vect){
   sendData();
}



/*
  Prepare data packet, attach 0 to telemetry bit, and calcluate CRC
  throttle: 11-bit data
*/
static uint16_t createPacket(uint16_t throttle){
  uint8_t csum = 0;
  throttle <<= 1;
  uint16_t csum_data = throttle;
  for (byte i=0; i<3; i++){
    csum ^= csum_data;
    csum_data >>= 4;
  }
  csum &= 0xf;
  return (throttle<<4)|csum;
}

/****************** end of static functions *******************/

DShot::DShot(int id){
  _packet = createPacket(0);
  pinMode(OUTPUT_PIN, OUTPUT);
  if (!isTimerActive()){
    initISR();
  }
}

/*
  Set the throttle value and prepare the data packet and store
  throttle: 11-bit data
*/
uint16_t DShot::setThrottle(uint16_t throttle){
  this->_throttle = throttle;
  this->_packet = createPacket(throttle);
  dShotPacket = _packet;
  return _packet;
}
