#include "Arduino.h"
#include "DShot.h"

// Each item contains the bit of the port
static uint8_t dShotBits[16];

// Denote which pin is attached to dShot
static uint8_t dShotPins = 0;

static inline void sendData(){
  noInterrupts();
  for (uint8_t i=0; i<16; i++){
    // Set High for every attached pins
    OUTPUT_PORT |= dShotPins;
    // wait about 1.25us
    NOP8;NOP4;NOP2;
    // Set Low for low bits only
    OUTPUT_PORT &= ~((~dShotBits[i]) & dShotPins);
    NOP8;NOP4;
    // Turn off everything
    OUTPUT_PORT &= ~dShotPins;
    NOP2;
  }
  interrupts();
}

/*
  Generated by:
  http://www.8bit-era.cz/arduino-timer-interrupts-calculator.html
  1000 Hz Update rate
*/
static void initISR(){
  // TIMER 1 for interrupt frequency 1000 Hz:
  cli(); // stop interrupts
  TCCR1A = 0; // set entire TCCR1A register to 0
  TCCR1B = 0; // same for TCCR1B
  TCNT1  = 0; // initialize counter value to 0
  // set compare match register for 1000 Hz increments
  OCR1A = 15999; // = 16000000 / (1 * 1000) - 1 (must be <65536)
  // turn on CTC mode
  TCCR1B |= (1 << WGM12);
  // Set CS12, CS11 and CS10 bits for 1 prescaler
  TCCR1B |= (0 << CS12) | (0 << CS11) | (1 << CS10);
  // enable timer compare interrupt
  TIMSK1 |= (1 << OCIE1A);
  sei(); // allow interrupts
}

static boolean isTimerActive(){
  return true;
}

ISR(TIMER1_COMPA_vect){
   sendData();
}

/*
  Prepare data packet, attach 0 to telemetry bit, and calcluate CRC
  throttle: 11-bit data
*/
static uint16_t createPacket(uint16_t throttle){
  uint8_t csum = 0;
  throttle <<= 1;
  uint16_t csum_data = throttle;
  for (byte i=0; i<3; i++){
    csum ^= csum_data;
    csum_data >>= 4;
  }
  csum &= 0xf;
  return (throttle<<4)|csum;
}

/****************** end of static functions *******************/

DShot::DShot(uint8_t pin){
  this->_packet = createPacket(0);
  this->_pin = pin;
  pinMode(pin, OUTPUT);
  if (!isTimerActive()){
    initISR();
    for (byte i=0; i<16; i++){
      dShotBits[i] = 0;
      dShotPins = 0;
    }
  }
  dShotPins |= _BV(pin);
}

/*
  Set the throttle value and prepare the data packet and store
  throttle: 11-bit data
*/
uint16_t DShot::setThrottle(uint16_t throttle){
  this->_throttle = throttle;

  // TODO: This part can be further optimized when combine with create packet
  this->_packet = createPacket(throttle);
  uint16_t mask = 0x8000;
  for (byte i=0; i<16; i++){
    if (this->_packet & mask)
      dShotBits[i] |= _BV(this->_pin);
    else
      dShotBits[i] &= ~(_BV(this->_pin));
    mask >>= 1;
  }
  return _packet;
}
